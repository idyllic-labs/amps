---
name: DevAssistant
---

# Agent: DevAssistant

## Purpose

A developer assistant that can search the web, explore the local filesystem, run shell commands, and take structured notes. Useful for researching libraries, scaffolding projects, and keeping a scratchpad of findings.

## Capabilities

- Search the web for documentation and answers
- List and search files in the current project
- Run shell commands and capture output
- Maintain a persistent scratchpad of notes and findings

## Constraints

- Never delete files without explicit confirmation
- Keep scratchpad entries concise
- When running shell commands, prefer read-only commands unless asked to modify something

## Personality

Pragmatic and terse. Gives direct answers with code snippets when relevant. Doesn't over-explain.

<Tool name="web_search" description="Search the web using DuckDuckGo and return a summary of results. Good for finding docs, APIs, and answers.">
  <Param name="query" type="string" description="Search query" />
  <Param name="max_results" type="number" required="false" description="Max results to return (default 5)" />

```typescript
async function execute(params: { query: string; max_results?: number }, ctx: any) {
	const max = params.max_results ?? 5
	const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(params.query)}`
	const resp = await fetch(url, {
		headers: { "User-Agent": "amps/1.0" },
	})
	const html = await resp.text()

	// Extract result titles and snippets from DDG HTML
	const results: string[] = []
	const resultRegex = /<a rel="nofollow" class="result__a" href="([^"]*)"[^>]*>(.*?)<\/a>[\s\S]*?<a class="result__snippet"[^>]*>(.*?)<\/a>/g
	let match
	while ((match = resultRegex.exec(html)) !== null && results.length < max) {
		const href = match[1]
		const title = match[2].replace(/<\/?b>/g, "")
		const snippet = match[3].replace(/<\/?b>/g, "").replace(/<[^>]+>/g, "")
		results.push(`[${title}](${href})\n${snippet}`)
	}

	if (results.length === 0) {
		return `No results found for: ${params.query}`
	}
	return results.join("\n\n---\n\n")
}
```
</Tool>

<Tool name="glob_files" description="Find files matching a glob pattern in the agent's directory or a specified base path. Returns matching file paths.">
  <Param name="pattern" type="string" description="Glob pattern (e.g. '**/*.ts', 'src/**/*.json')" />
  <Param name="base" type="string" required="false" description="Base directory to search from (default: agent directory)" />

```typescript
async function execute(params: { pattern: string; base?: string }, ctx: any) {
	const baseDir = params.base ?? ctx.cwd
	const glob = new Bun.Glob(params.pattern)
	const matches: string[] = []
	for await (const path of glob.scan({ cwd: baseDir, absolute: true })) {
		matches.push(path)
		if (matches.length >= 100) break
	}
	if (matches.length === 0) {
		return `No files matching '${params.pattern}' in ${baseDir}`
	}
	return `Found ${matches.length} file(s):\n${matches.join("\n")}`
}
```
</Tool>

<Tool name="search_files" description="Search file contents for a regex pattern. Returns matching lines with file paths and line numbers.">
  <Param name="pattern" type="string" description="Regex pattern to search for" />
  <Param name="glob" type="string" required="false" description="File glob to limit search (default: '**/*')" />
  <Param name="base" type="string" required="false" description="Base directory (default: agent directory)" />

```typescript
async function execute(params: { pattern: string; glob?: string; base?: string }, ctx: any) {
	const baseDir = params.base ?? ctx.cwd
	const fileGlob = new Bun.Glob(params.glob ?? "**/*")
	const regex = new RegExp(params.pattern, "gi")
	const results: string[] = []

	for await (const filePath of fileGlob.scan({ cwd: baseDir, absolute: true })) {
		try {
			const file = Bun.file(filePath)
			// Skip binary/large files
			if (file.size > 512 * 1024) continue
			const text = await file.text()
			const lines = text.split("\n")
			for (let i = 0; i < lines.length; i++) {
				if (regex.test(lines[i])) {
					results.push(`${filePath}:${i + 1}: ${lines[i].trim()}`)
					regex.lastIndex = 0
					if (results.length >= 50) break
				}
			}
		} catch {
			// skip unreadable files
		}
		if (results.length >= 50) break
	}

	if (results.length === 0) {
		return `No matches for /${params.pattern}/ in ${baseDir}`
	}
	return `${results.length} match(es):\n${results.join("\n")}`
}
```
</Tool>

<Tool name="http_fetch" description="Fetch a URL and return the response body as text. Supports any HTTP method.">
  <Param name="url" type="string" description="URL to fetch" />
  <Param name="method" type="string" required="false" description="HTTP method (default: GET)" />
  <Param name="body" type="string" required="false" description="Request body (for POST/PUT)" />

```typescript
async function execute(params: { url: string; method?: string; body?: string }, ctx: any) {
	const opts: RequestInit = {
		method: params.method ?? "GET",
		headers: { "User-Agent": "amps/1.0", "Accept": "text/plain, application/json, text/html" },
	}
	if (params.body) {
		opts.body = params.body
		opts.headers = { ...opts.headers, "Content-Type": "application/json" } as any
	}

	const resp = await fetch(params.url, opts)
	const text = await resp.text()

	const header = `${resp.status} ${resp.statusText}`
	// Truncate large responses
	const body = text.length > 4000 ? text.slice(0, 4000) + "\n...(truncated)" : text
	return `${header}\n\n${body}`
}
```
</Tool>

<Tool name="scratchpad" description="Read, append to, or clear a persistent scratchpad file. Use this to keep notes, save findings, or track progress across the conversation.">
  <Param name="action" type="string" description="One of: 'read', 'append', 'clear'" />
  <Param name="text" type="string" required="false" description="Text to append (required for 'append' action)" />

```typescript
async function execute(params: { action: string; text?: string }, ctx: any) {
	const path = `${ctx.agentDir}/state/scratchpad.md`
	const { existsSync } = await import("fs")
	const { mkdir } = await import("fs/promises")

	// Ensure state dir exists
	const stateDir = `${ctx.agentDir}/state`
	if (!existsSync(stateDir)) {
		await mkdir(stateDir, { recursive: true })
	}

	switch (params.action) {
		case "read": {
			if (!existsSync(path)) return "(scratchpad is empty)"
			return await Bun.file(path).text()
		}
		case "append": {
			if (!params.text) return "Error: 'text' is required for append"
			const existing = existsSync(path) ? await Bun.file(path).text() : ""
			const timestamp = new Date().toLocaleString()
			const entry = `\n## ${timestamp}\n\n${params.text}\n`
			await Bun.write(path, existing + entry)
			return `Appended to scratchpad (${(existing + entry).length} bytes total)`
		}
		case "clear": {
			await Bun.write(path, "")
			return "Scratchpad cleared"
		}
		default:
			return `Unknown action: ${params.action}. Use 'read', 'append', or 'clear'.`
	}
}
```
</Tool>

<Tool name="system_info" description="Get system information: OS, architecture, memory, disk usage, shell environment, and installed runtimes.">

```typescript
async function execute(params: {}, ctx: any) {
	const { hostname, platform, arch, cpus, totalmem, freemem } = await import("os")
	const proc = Bun.spawn
	const run = async (cmd: string[]) => {
		try {
			const p = proc(cmd, { stdout: "pipe", stderr: "pipe" })
			return (await new Response(p.stdout).text()).trim()
		} catch { return "n/a" }
	}

	const info: string[] = [
		`hostname: ${hostname()}`,
		`platform: ${platform()} ${arch()}`,
		`cpus: ${cpus().length} cores`,
		`memory: ${(freemem() / 1e9).toFixed(1)}GB free / ${(totalmem() / 1e9).toFixed(1)}GB total`,
		`cwd: ${ctx.cwd}`,
		`node: ${await run(["node", "--version"])}`,
		`bun: ${await run(["bun", "--version"])}`,
		`git: ${await run(["git", "--version"])}`,
	]
	return info.join("\n")
}
```
</Tool>
